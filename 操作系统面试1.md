# 操作系统面试真题



## 1、简述进程、线程和程序的区别

### 进程

进程是程序的一次执行过程，是系统运行的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建、运行到消亡的过程。每个进程还占有某些系统资源如cpu时间、内存空间、文件、输入输出设备的使用权等。

### 程序

程序是含有指令和数据的文件，被存储在磁盘或其他数据存储设备中，也就是说程序是静态的代码。

#### 进程与程序的区别联系

进程是程序的一次动态运行实例，程序是可以被保存的，而进程只是暂时的。即进程是动态的概念，程序是静态的概念；
程序只是文件，它是一系列代码指令的集合，而进程是程序被加载到内存，并衍生出一系列的结构体来维护的。

### 线程

线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源。所以系统在产生一个线程，或者是在各个线程之间切换时，负担要比进程小的多，也正因为如此，线程也被称为轻量级进程。

#### 进程与线程的区别

他们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的栈空间和局部变量，单线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序更强大，但在进程切换时，资源耗费较大，效率较低。

一个程序可以有多个进程，一个进程可以有多个线程。



## 2、简述fork()函数，以及在多进程中需要注意的事项



### 一、fork()函数

fork函数是从一个已存在的进程中创建一个新进程。

系统调用函数fork()是创建一个新进程的唯一方式，fork()函数是Linux系统中一个比较特殊的函数，其一次调用会有两个返回值，当程序调用fork()函数并返回成功之后，程序就将变成两个进程，调用fork()者为父进程，后来生成者为子进程。这两个进程将执行相同的程序文本，但是有不同的栈段、数据段以及堆栈拷贝。子进程的栈、数据以及栈段开始时是父进程内存相应各部分的完全拷贝，因此它们互不影响。

二、fork()与多线程

在多线程执行的情况下调用fork()函数,仅会将发起调用的线程复制到子进程中。也就是说不能同时创建出于父进程一样多线程的子进程。 其他线程均在子进程中立即停止并消失，并且不会为这些线程调用清理函数以及针对线程局部存储变量的析构函数。这将导致下列一些问题:  

1.例如:一个线程在fork()被调用前锁定了某个互斥量,且对某个全局变量的更新也做到了-半,此时fork()被调用,所有数据及状态被拷贝到子进程中,那么子进程中对该互斥量就无法解锁, 如果再试图锁定该互斥量就会导致死锁。

### 三、 总结  

fork()函数的调用会导致在子进程中除调用线程外的其它线程全都终止执行并消失,因此在多线程的情况下会导致死锁和内存泄露的情况。在进行多线程编程的时候尽量避免fork()的调用,同时在程序在进入main函数之前应避免创建线程,因为这会影响到全局对象的安全初始化。线程不应该被强行终止，因为这样它就没有机会调用清理函数来做相应的操作,同时也就没有机会来释放已被锁住的锁,如果另-线程对未被解锁的锁进行加锁 ,那么将会立即发生死锁,从而导致程序无法正常运行。



## 3、进程有那些状态，如何进行相互切换的。

1.进程的五状态模型：

运行态： 就绪态： 阻塞态（等待态）：新建态： 终止态：

2.导致转换的事件：

空 转换为 新建：创建执行一个程序的新进程，可能的事件有：新的批处理作业、交互登录（终端用户登录到系统）、操作系统因为提供一项服务而创建、由现有的进程派生等。

新建->就绪：操作系统准备好再接纳一个进程时，把一个进程从新建态转换为就绪态。

就绪->运行：需要选择一个新进程运行时，操作系统的调度器或分配器根据某种调度算法选择一个处于就绪态的进程。

运行->退出：导致进程终止的原因有：正常完成、超过时限、系统无法满足进程需要的内存空间、进程试图访问不允许访问的内存单元（越界）、算术错误（如除以0或存储大于硬件可以接纳的数字）、父进程终止（操作系统可能会自动终止该进程所有的后代进程）、父进程请求终止后代进程等。

运行->就绪：最常见的原因是，正在运行的进程到达了“允许不中断执行”的最大时间段，该把处理器的资源释放给其他在就绪态的进程使用了；还有一中原因可能是由于具有更改优先级的就绪态进程抢占了该进程的资源，使其被中断转换到就绪态。

运行->阻塞：如果进程请求它必须等待的某些事件，例如一个无法立即得到的资源（如I/O操作），只有在获得等待的资源后才能继续进程的执行，则进入等待态（阻塞态）。

阻塞->就绪：当等待的事件发生时，处于阻塞态的进程转换到就绪态。

就绪->终止：在某些进程中，父进程可以在任何时刻终止一个子进程，如果一个父进程终止，所有相关的子进程都被终止。

阻塞->终止：跟上一项原因类似。


