# 十大排序  

## <table><tr><td bgcolor=orange>选择排序　　 $n^2$　　不稳　　</td></tr></table>
* 将整个数组遍历一遍，将最小的数和首个元素互换
然后从第二个元素开始遍历数组，将剩余最小的和第二个互换
以此类推。

* 举个例子，对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4.对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。  

##### 复杂度及优缺点
选择排序总比较次数=(n-1)+(n-2)+(n-3)+...+3+2+1=n(n-1)/2

n(n-1)/2是O(n^2)阶的级，所以

选择排序的速度是阶O(n^2)的算法。

空间是o(1)的算法

适用于小列表排序。

其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。

选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。  

```    
C++
template <typename T>
void Insertion_Sort(T *array, size_t length) {
    if (length <= 1) {
        return;
    } else {
        for (int i = 1; i != length; i++) {
            int j = i - 1;
            T key = array[i];
            while (j >= 0 && array[j] > key) {
                array[j + 1] = array[j];
                j--;
            }
            array[j + 1] = key;
        }
    }
}
```
```  
C
#include <stdio.h>
int main()
{
    int i,j,t,a[11];    //定义变量及数组为基本整型
    printf("请输入10个数：\n");
    for(i=1;i<11;i++)
        scanf("%d",&a[i]);    //从键盘中输入要排序的10个数字
    for(i=1;i<=9;i++)
        for (j=i+1;j<=10;j++)
            if(a[i]>a[j])    //如果前一个数比后一个数大，则利用中间变量t实现两值互换
            {
                t=a[i];
                a[i]=a[j];
                a[j]=t;
            }
    printf("排序后的顺序是：\n");
    for(i=1;i<=10;i++)
        printf("%5d", a[i]);    //输出排序后的数组
    printf("\n");
    return 0;
}
```

---

## <table><tr><td bgcolor=orange>冒泡排序　　 $n^2$　　稳 　　</td></tr></table>
总体思想
其大体思想就是通过与相邻元素的比较和交换来把大的数交换到最后面。这个过程类似于水泡向上升一样，因此而得名

1 比较相邻的元素。如果第一个比第二个大，就交换他们两个。  
2 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。  
3 针对所有的元素重复以上的步骤，除了最后一个。  
4 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。  
##### 复杂度及优缺点
泡排序总比较次数=(n-1)+(n-2)+(n-3)+...+3+2+1=n(n-1)/2

n(n-1)/2是O(n^2)阶的级，所以

冒泡排序速度是阶O(n^2)的算法。

最差情况是O(n^2)，最好情况，普通算法是O(n^2)，优化过是O(n)

空间是o（1）的算法

速度很慢，因为还要不断交换

冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。

##### 优化
设置一个变量，初始值为false，当发生一次交换就将变量设置为true，如果循环完后还是false，说明数组已经有序，结束循环。

所以最优情况下速度为o(n)

如果原始有序，那么一次扫描完一次交换也不会有，即变量=false，此时return，终止排序。此时时间复杂度是O（n）.

note:原始数据只要有一对需要改顺序，复杂度就又会变成O(n^2)的。
##### 代码　　

```  
void bubble_sort(int *num,int n){
	 int times = 1;
    for (int i = 1; i < n && times; i++) {
        times = 0;
        for (int j = 0; j < n - i; j++) {
            if (num[j] <= num[j + 1]) continue;
            swap(num[j], num[j + 1]);
            times++;
        }
    }
	return ;
}
```
----
　　
## <table><tr><td bgcolor=orange>插入排序　　 $n^2$　　稳　　</td></tr></table>  
##### 总体思想　　
1 将数组划分为已排序的和未排序的，已排序的在前，初始为第一个
2 每次循环，从未排序的取出第一个，按照大小，插入已排序的数组的对应位置，比它大的依次向后移动一位

或者

1）将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

2）从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

举个栗子，对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置时正确的，想一下在拿到第一张牌的时候，没必要整理。然后3要插到5前面，把5后移一位，变成3,5,8,6,4.想一下整理牌的时候应该也是这样吧。然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经有序。
##### 复杂度及优缺点
简单插入排序的时间复杂度也是O(n^2)。

最佳用例效率：O(n)，当列表已经被排序时，产生最佳用例。

最差用例效率：O(n^2)，当列表反向顺序排列时，产生最差用例。

插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳 定的。  

##### 代码　　
```  
C　语言
void insert_sort(int *num, int n) {
    for (int i = 1; i < n; i++) {
        for (int j = i; j > 0 && num[j] < num[j - 1]; --j) {
            swap(num[j], num[j - 1]);
        }
    }
    return ;
}
```

---

## <table><tr><td bgcolor=orange>快速排序 　　n$\log$(n)　　不稳 　　</td></tr></table>  
##### 总体思想
快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。

1 从数列中挑出一个元素，称为 “基准”（pivot），

2 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。

3 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

 

1、先从数列中取出一个数作为基准数  
2、分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边  
3、再对左右区间重复第二步，直到各区间只有一个数
复杂度及优缺点
快速排序是不稳定的，它的速度与它的基准点有关，基准点的好坏大大影响速度

在最差情况下，划分由 n 个元素构成的数组需要进行 n 次比较和 n 次移动。因此划分所需时间为 O(n) 。最差情况下，每次主元会将数组划分为一个大的子数组和一个空数组。这个大的子数组的规模是在上次划分的子数组的规模减 1 。该算法需要 (n-1)+(n-2)+…+2+1= O(n^2) 时间。 
在最佳情况下，每次主元将数组划分为规模大致相等的两部分。设 T(n) 表示使用快速排序算法对包含 n 个元素的数组排序所需的时间，因此，和归并排序的分析相似，快速排序的 T(n)= O(nlogn)。

##### 空间复杂度

其实这个空间复杂度不太好计算，因为有的人使用的是非就地排序，那样就不好计算了（因为有的人用到了辅助数组，所以这就要计算到你的元素个数了）；我就分析下就地快速排序的空间复杂度吧；

首先就地快速排序使用的空间是O(1)的，也就是个常数级；而真正消耗空间的就是递归调用了，因为每次递归就要保持一些数据；

最优的情况下空间复杂度为：O(logn)  ；每一次都平分数组的情况

最差的情况下空间复杂度为：O( n )      ；退化为冒泡排序的情况

快速排序有两个方向，左边的i下标一直往右走，当a[i] <= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] > a[center_index]。如果i和j都走不动了，i <= j, 交换a[i]和a[j],重复上面的过程，直到i>j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。  
```
void quilck_sort (int *num, int l,int r) {
	if (r <= l) return ;
	int x = l, y = r, z = num[l];
	while (x < y) {
		while (x < y && num[y] >= z) --y;
		if (x < y)	num[x++] = num[y];
		while (x < y && num[x] <= z) ++x;
		if (x < y)	num[y--] = num[x];
	}
	num[x] = z;
	quick_sort(num, l, x - 1);
	quick_sort(num, x + 1, r);
}

```  


---
　
## <table><tr><td bgcolor=orange>归并排序　　 n$\log$(n)　　稳　　 　　</td></tr></table> 
##### 总体思想
多次将若干个已经排序好的有序表合并成一个有序表。直接将两个表合并的归并成为二路归并。

其基本思想是，先递归划分子问题，然后合并结果。把待排序列看成由两个有序的子序列，然后合并两个子序列，然后把子序列看成由两个有序序列。。。。。倒着来看，其实就是先两两合并，然后四四合并。。。最终形成有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。



首先mergeSort(nums,0,length-1)
进行递归
首先mergeSort数组begin与end的左侧，让左侧有序
再mergerSort右侧
左侧和右侧都有序后，对左侧和右侧进行merge，一起排序
由于此次排序左右都有序，建立一个临时数组，对左右从头到尾进行扫描，谁小就进入数组，一遍扫描即可  
##### 复杂度及优缺点
时间复杂度为O(nlogn)。

空间复杂度为O(n)。

速度较快，但是需要额外的空间

归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。
``` 
void merge_sort(int *num ,int l,int r){
	if(r-l<=1){
		if(r-l==1&& num[l]>num[r]){
			swap(num[l],num[r]);
		}
		return ;
	}
	int mid=(l+r)>>1;
	merge_sort(num,l,mid);
	merge_sort(num,mid+1,r);
	int *temp=(int *)malloc (sizeof(int)*(r-l+1));
	int p1=l,p2=mid+1,k=0;
	while(p1<=mid || p2<=r){
		if(p2>r||(p1<=mid && num[p1]<=num[p2])){
			temp[k++]=num[p1++];

		}else{
			temp[k++]=num[p2++];
		}
	}
	memcpy(num+l,temp,sizeof(int)*(r-l+1));
	free(temp);
	return ;
}
```
---

## <table><tr><td bgcolor=orange>堆排序　　   n$\log$(n)　　不稳 　　 　　</td></tr></table> 
##### 总体思想
利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。  

堆排序是借助堆来实现的选择排序，思想同简单的选择排序，以下以大顶堆为例。注意：如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。  

　　首先，实现堆排序需要解决两个问题：

　　1. 如何由一个无序序列键成一个堆？

　　2. 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？

　　第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。

　　第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。

　　从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可
##### 复杂度及优缺点
堆排序的平均时间复杂度为Ο(nlogn) 。

我们知道堆的结构是节点i的孩子为2*i和2*i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, ...1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。

---
 
## <table><tr><td bgcolor=orange>希尔排序　　n的1.3　　　不稳 　　 　　</td></tr></table> 
##### 总体思想
希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性的效率

但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位

希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。

子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。 
复杂度及优缺点
希尔排序的速度与它选择的递减数组密切相关，速度快的数组，最好是互质的

如果选择不好，可能o(n^2)

希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到O(n^1.3)。
 希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。

---

## <table><tr><td bgcolor=orange>桶排序　　(n+k)　　　稳 　　</td></tr></table> 
##### 总体思想
简单来说就是把数组 arr 划分为n个大小相同子区间（桶），每个子区间各自排序，最后合并。这样说是不是和分治法有点像了 啊！因为分治法就是分解 —— 解决 ——合并这样的套路。我认为这样想没毛病。可以理解为桶排序是一种特殊的分治法，特殊的地方主要体现在前两部分（这样说不知道对不对~）。
分组排序的算法可以用快速排序，因为内部的元素比较随机，速度快

假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。 
##### 复杂度及优缺点
桶排序是计数排序的改进，当桶每次只装一个的时候，就是计数排序

桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。
对N个关键字进行桶排序的时间复杂度分为两个部分：
(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。  
(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。  
很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点：  
(1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。  
(2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。 当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。  
对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：  
O(N)+O(M*(N/M)*log(N/M))=O(N+N*(logN-logM))=O(N+N*logN-N*logM)  
当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。  
总结：桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。当然桶排序的空间复杂度为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是的稳定程度与桶的内部排序算法的稳定程度相同。


---

## <table><tr><td bgcolor=orange>计数排序　　(n+k)　　　稳  　　</td></tr></table> 
##### 总体思想
首先找到数组中的最大值，然后新建一个数组，bucket 此数组的长度是数组最大值+1，其实新建的这个数组中的下标值就是原数组的数据值，这里为什么长度是数组最大值加一呢  
注意*：是因为比如数组最大值是9，然后如果你设置bucket数组的长度为9，那么他的下标最大值就是8，那么原数组的9就没有桶存了  
好了继续，找到最大值后，开始遍历原数组，把原数组的数据加入bucket的下表中，bucket[i]，每当有1个i bucket[i]的值就加一， 然后已经装入桶后， 遍历桶，如果bucket[j]位置-->0就说明此下标有数据，也就是说，此下标在原数组里有这个值， 然后排序 就是从大到小了 arr[i++]=j;

然后将原数组的按个=新的数组的元素（有几个的话，=多次，比如nums[2]=5,nums[3]=5）
##### 复杂度及优缺点
计数排序是一种非常快捷的稳定性强的排序方法，时间复杂度O(n+k),其中n为要排序的数的个数，k为要排序的数的组max-min+1。

计数排序对一定量的整数排序时候的速度非常快，一般快于其他排序算法。但计数排序局限性比较大，只限于对整数进行排序。计数排序是消耗空间发杂度来获取快捷的排序方法，其空间发展度为O（K）同理K为要排序的max-min+1。
##### 计数排序与BitMap 
bitmap 算法

https://blog.csdn.net/xushiyu1996818/article/details/89880902

计数排序和bitmap十分相似，互为变种，都能够在O(n)时间内排序，O(K)空间复杂度

区别在于

计数排序对每一个数字设置了一个int，能够发现总共出现了几次，但是相当于消耗了32个bit，浪费空间。

普通的bitmap对每个数字，只设置了一个bit，节省空间，但是只能发现这个数字有没有出现，不能发现出现几次。

所以对普通的排序，计数排序即可，但是对不仅仅要排序，还要去重，可以使用bitmap


---
## <table><tr><td bgcolor=orange>基数排序　　n*k　　　稳　 　　</td></tr></table> 
##### 总体思想
基数排序又称为“桶子法”，从低位开始将待排序的数按照这一位的值放到相应的编号为0~9的桶中。等到低位排完得到一个子序列，再将这个序列按照次低位的大小进入相应的桶中，一直排到最高位为止，数组排序完成。

基数排序不同于其他的排序算法，它不是基于比较的算法。基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。它是一种稳定的排序算法。多关键字排序中有两种方法：最高位优先法(MSD)和最低位优先法（LSD）。通常用于对数的排序选择的是最低位优先法，即先对最次位关键字进行排序，再对高一位的关键字进行排序，以此类推。

算法的思想：类似于桶式排序，我们需要给待排序记录准备10个桶，为什么是10个？？因为一个数的任何一位上，其数字大小都位于0~9之间，因此采用10个桶，桶的编号分别为0,1,2,3,4...9，对应待排序记录中每个数相应位的数值，基数排序也是因此而得名。我们先根据待排序记录的每个数的个位来决定让其加入哪个桶中。 
##### 复杂度及优缺点
 

基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。

---
#### 快速排序　　n$\log$(n)　　不稳　 
快速排序是对冒泡排序的一种改进.  
快速排序思想：
1.选择数组左边第一个元素为枢轴pivot，把数组所有元素比pivot大的放在数组右边，比pivot小的放在左边
（复杂度为O(n)）
2.对pivot左右两边的序列分别进行快速排序。
(1)首先设定一个分界值，通过该分界值将数组分成左右两部分。  
(2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值.  
(3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。   
(4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。  
##### 时间复杂度和优化　　
T(1) = 1;  
T(n) = 2*T(n/2) + a*n;(a为常数，每次合并时，复杂度为O(n))  
= 2*(2*T(n/4)+a*n/2) + a*n  
= 4*T(n/4) + 2*a*n  
= 4*(2*T(n/8)+a*n/4) + 2*a*n  
= 8*T(n/8) + 3*a*n  
=......  
= 2^k*T(1) + k*a*n  (其中n==2^k,即k=log2(n))  
= n + a*n*log2(n);  
所以时间复杂度为O(nlogn)  
注意：对左右分别快排时，可能出现一遍元素个数为0，这是最坏情况，此时时间复杂度为O(n^2)

##### 代码
```  
C 语言
void sort(int *a, int left, int right)
{
    if(left >= right)/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/
    {
        return ;
    }
    int i = left;
    int j = right;
    int key = a[left];
     
    while(i < j)                               /*控制在当组内寻找一遍*/
    {
        while(i < j && key <= a[j])
        /*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升
        序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/ 
        {
            j--;/*向前寻找*/
        }
         
        a[i] = a[j];
        /*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是
        a[left]，那么就是给key）*/
         
        while(i < j && key >= a[i])
        /*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，
        因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/
        {
            i++;
        }
         
        a[j] = a[i];
    }
     
    a[i] = key;/*当在当组内找完一遍以后就把中间数key回归*/
    sort(a, left, i - 1);/*最后用同样的方式对分出来的左边的小组进行同上的做法*/
    sort(a, i + 1, right);/*用同样的方式对分出来的右边的小组进行同上的做法*/
                       /*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/
}
```