## 1、如果现在有k个有序数组，如何合并成一个。

两种方法：

1、可以使用归并排序。

2、利用小顶堆完成；

用小顶堆实现的具体过程：



## 2、具体说明，为什么归并排序适合处理大数据排序情况？

外部排序

多路归并排序

## 3、如何快速的输出无序数组中前k大的值，请说明你的方法，并分析时间复杂度。

选择排序





 



























1、

假设每个数组有n个元素，一共有k个数组。

首先建一个大小为n*k的数组保存最后的结果
建一个大小为k的最小堆，堆中元素为k个数组中的每个数组的第一个元素

重复下列步骤n*k次：

然后开始执行操作：

每次从堆中取出最小元素（堆顶元素），并将其存入输出数组中，也就是大小为n × k那个数组中。
用堆顶元素所在数组的下一元素将堆顶元素替换掉，
如果数组中元素被取光了，将堆顶元素替换为无穷大。每次替换堆顶元素后，重新调整堆。然后执行同样的操作n * k次。

初始化小顶堆的时间复杂度O（k），总共执行了k * n次，每次循环调整最小堆的时间复杂度是O（logk），所以总的时间复杂度是O（knlogk）。





2、

归并排序是一种外部排序，外部排序指的是大文件的排序，它将待排序的数据记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，来达到排序整个大数据的目的。

外部排序最常用的算法是多路归并排序，它是将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成排序，所以就是将一个数据很大的问题转化成多个小数据排序问题。然后，对已经排序的子文件进行多路归并排序。



3、

因为只需要输出前k大的值，不需要对完整的数据进行排序，所以使用选择排序，分为已排序去和未排序去，    将已排序去长度设为k,就可以得到前k大的值，每次寻找未排序去中最大的值的时间复杂度为O(n),执行k次，所以整体的时间复杂度是O（n * k）











那如果选用最小堆的数据结构来解决，最顶端是最小值，再次遇到比它大的值，就可以入堆，入堆后重新调整堆，将小的值pass掉。这样我们就可以选出最大的前K个数据了。言外之意，假若我们要找出N个数据中最小的前k个数据，就要用最大堆了。